pub use crate::prelude::*;
use anyhow::Result;
use quote::quote;
use std::path::Path;
use sweet::prelude::*;
use syn::File;




pub struct ParseDirRoutes;


impl ParseDirRoutes {
	/// Visit all rust files non-recursively and collect
	/// any routes in the file.
	/// This will result in a `collect_routes` function
	/// as well as static paths for any routes, ie INDEX.
	pub fn build_string(config: &CollectRoutes, path: &Path) -> Result<String> {
		let routes_dir_name = config.routes_dir.to_string_lossy();
		let page_routes = ReadDir::files(path)?
			.into_iter()
			.filter(|path| {
				path.extension().map_or(false, |ext| ext == "rs")
					&& path.file_name().map_or(false, |f| f != "mod.rs")
			})
			.map(|path| FileRoute::new(&routes_dir_name, path))
			.collect::<Result<Vec<_>>>()?;

		let add_routes = page_routes.iter().map(|f| f.add_routes()).flatten();

		// the pub const INDEX:&'static str =
		let static_route_paths = page_routes.iter().map(|f| f.static_path());

		let route_type: syn::Type = syn::parse_str(&config.route_type)?;

		// let ident_tokens =
		// let ident = syn::Ident::new(route_type, Span::call_site());
		// let syn_path: syn::Path = parse_quote!(#route_type);
		// let syn_path = syn_path.to_token_stream();

		let prefix_tokens: File = config
			.file_router_tokens
			.as_ref()
			.map(|tokens| syn::parse_str(tokens))
			.unwrap_or_else(|| {
				Ok(syn::parse_quote! {
					use beet::prelude::*;
				})
			})?;

		let dir_idents = ReadDir::dirs(path)?
			.into_iter()
			.map(|path| {
				let name = path
					.file_stem()
					.expect("dir has no stem")
					.to_string_lossy();
				syn::Ident::new(&name, proc_macro2::Span::call_site())
			})
			.collect::<Vec<_>>();
		let include_files = ReadDir::files(path)?
			.into_iter()
			.filter(|path| {
				path.extension().map(|ext| ext == "rs").unwrap_or(false)
					&& path.file_name().unwrap() != "mod.rs"
			})
			.map(|path| {
				let name = path
					.file_stem()
					.expect("file has no stem")
					.to_string_lossy();
				let ident =
					syn::Ident::new(&name, proc_macro2::Span::call_site());
				quote! {pub mod #ident; }
			});
		let include_dirs =
			dir_idents.iter().map(|ident| quote! {pub mod #ident;});
		let children = dir_idents.iter().map(|ident| {
			quote! {#ident::collect(router)}
		});

		let file: File = syn::parse_quote! {
			//! 🥁🥁🥁 This file has been auto generated by the Beet router.
			//! 🥁🥁🥁 Any changes will be overridden if the file is regenerated.
			// include routes
			#(#include_files)*
			// include sub routes
			#(#include_dirs)*
			// declare static routes
			#(#static_route_paths)*
			#prefix_tokens
			#[cfg(not(target_arch = "wasm32"))]
			pub fn collect()->RouteTree<#route_type> {
				RouteTree{
					children: vec![#(#children),*],
					..Default::default()
				}
				#(.add_route(#add_routes))*
			}
		};
		let file = prettyplease::unparse(&file);

		Ok(file)
	}
}
